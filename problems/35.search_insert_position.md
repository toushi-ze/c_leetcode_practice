# 35.search_insert_position

## 题目介绍

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会
被按顺序插入的位置，必须使用时间复杂度为O(logn)的算法。
```
示例 1:
输入:nums=[1,3,5,6]，target =5
输出：2
示例2:
输入:nums=[1,3,5,6]，target =2
输出：1
示例 3:
输入:nums=[1,3,5,6]，target =7
输出：4
```

## 解题思路

初期思路（暴力求解）:
1. 如果数组为空（长度为 0），直接返回0；
2. 逐一遍历数组：从头开始遍历每个元素，找到第一个大于或等target 的元素，返回它的下标（存在是目标值下标，不存在是对应插入位置）；
3. 如果遍历完所有元素都没找到符合条件的，说明 target 比数组中所有元素都大，返回数组长度，相当于末尾插入。

```c
int searchInsert(int* nums, int numsSize, int target) {
    if (numsSize == 0) {
        return 0;
    }
    
    for (int i = 0; i < numsSize; i++) {
        if (target <= nums[i])
            return i;
    }
    return numsSize;
}
```

**优化**
题目要求时间复杂度要限制在O(logn)，上面解法并不满足，存在问题需要进一步优化。 
可以注意到题目所给的*排序数组*字样，上面解法并未利用这一核心条件，再结合给定的O(logn)时间复杂度，基本确认可以使用二分查找来进行优化
***思路***
1. 先定两个指针：left 指向数组开头，right 指向数组结尾；
2. 每次取中间位置 mid，拿 nums[mid] 和 target 比较：
   1. 相等：直接返回 mid
   2. nums[mid] < target：target 在右边，把 left 移到 mid+1
   3. nums[mid] > target：target 在左边，把 right 移到 mid-1
3. 循环结束没找到，说明 target 不存在，此时 left 就是插入位置（循环结束时 left > right，left 刚好指向比 target 大的第一个元素或数组末尾）
```c 
int searchInsert(int* nums, int numsSize, int target) {
    // 左边界left=0，右边界right=numsSize-1
    int left = 0;
    int right = numsSize - 1;
    
    // 左边界不超过右边界，继续查找
    while (left <= right) {
        // 计算中间下标
        int mid = (left + right) / 2;
        
        if (nums[mid] == target) {
            // 找到目标值，直接返回下标
            return mid;
        } else if (nums[mid] < target) {
            // 中间值比目标值小，说明目标值在右半部分，左边界右移
            left = mid + 1;
        } else {
            // 中间值比目标值大，说明目标值在左半部分，右边界左移
            right = mid - 1;
        }
    }
    
    // 循环结束还没返回，说明目标值不存在，返回左边界left（就是插入位置）
    return left;
}
```
**关键知识**  
二分查找

## 易错点

```c
int searchInsert(int* nums, int numsSize, int target) {
    int left = 0;
    int right = numsSize - 1;  // 数组的最大有效下标是 numsSize-1，right = numsSize 指向数组末尾之外
    
    while (left <= right) {  // 不能丢掉等于
        int mid = (left + right) / 2;
        
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return left;
}
```