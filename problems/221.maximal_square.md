# 221.maximal_square

## 题目介绍

题目给出一个二维矩阵，找出只包含1的最大正方形，返回其面积
```
输入矩阵：
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出：4（最大正方形的边长为 2，面积 = 2×2 = 4）
```
## 解题思路（暴力枚举）
通过枚举所有可能的正方形，逐一检查每个正方形是否全部由 '1' 组成，最终找到边长最大的那个正方形，返回其面积。  

正方形由*左上角起点*和*边长*唯一确定，枚举所有可能的起点和边长并记录最大值。  

1. 如果输入矩阵的行数为 0，或第一行的列数为 0（空矩阵），直接返回面积 0。
2. 遍历矩阵的每一个位置，将其作为正方形的左上角顶点
3. 枚举当前起点下的所有可能边长  
4. 检查当前边长的正方形是否全为 1
5. 更新最大正方形边长
6. 计算并返回最大面积
```c
// 辅助函数：求两个整数的最小值
int min(int a, int b) {
    if(a < b) {
        return a;
    }
    return b;
}


int maximalSquare(char** matrix, int matrixSize, int* matrixColSize) {
    // 空矩阵直接返回0
    if (matrixSize == 0 || matrixColSize[0] == 0) {
        return 0;
    }
    
    int rows = matrixSize;
    int cols = matrixColSize[0];
    int maxSize = 0; // 记录最大正方形的边长
    
    // 遍历所有可能的左上角起点
    for (int row = 0; row < rows; row++) {
        for (int col = 0; col < cols; col++) {
            // 尝试所有可能的正方形边长
            // 最大可能边长为：从当前点到矩阵右下角的最小距离
            int maxPossibleSize = min(rows - row, cols - col);
            for (int size = 1; size <= maxPossibleSize; size++) {
                bool noZero = true; 
                // 检查当前 size×size 的正方形内是否全为 '1'
                for (int dr = 0; dr < size; dr++) {
                    for (int dc = 0; dc < size; dc++) {
                        if (matrix[row + dr][col + dc] == '0') {
                            noZero = false;
                        }
                    }
                }
                // 如果全为1，更新最大边长
                if (noZero) {
                    if (size > maxSize) {
                        maxSize = size;
                    }
                } 
            }
        }
    }
    
    // 返回最大正方形的面积
    return maxSize * maxSize;
}
```
**优化**  
暴力枚举时间复杂度太高 不能有效率地处理大规模数据
可以使用动态规划解决这道题目 时间复杂度可以压到O(M×N)

设想一个大的3×3正方形，其内部必然包含了多个2×2的正方形。意味着这个大问题的解可以由小问题的解推导出来。这是动态规划信号！ 


解题最关键的思考点：一个格子i, j要想成为更大正方形的右下角，必须看三个方向的条件如何：左边 i, j-1能撑多大，上面i-1, j能撑多大，左上方i-1, j-1能撑多大。以下是完整代码

```c
// 辅助函数：求三个数的最小值 使用三元运算符更加紧凑
int min_three(int a, int b, int c) {
    int m = (a < b) ? a : b; 
    return (m < c) ? m : c;
}

int maximalSquare(char** matrix, int matrixSize, int* matrixColSize) {
    // 判空
    if (matrixSize == 0 || matrixColSize[0] == 0) 
    return 0;

    int rows = matrixSize;
    int cols = matrixColSize[0];
    int maxSize = 0;

    // 动态分配二维DP数组
    int** dp = (int**)malloc(rows * sizeof(int*));
    for (int i = 0; i < rows; i++) {
        // calloc自动将数组元素初始化为0
        dp[i] = (int*)calloc(cols, sizeof(int));
    }

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] == '1') {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1; // 注意边界
                } else {
                    // 调用min_three 找最小值
                    dp[i][j] = min_three(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1;
                }
                if (dp[i][j] > maxSize) maxSize = dp[i][j];
            } 
            // calloc已将dp[i][j]初始化为0
        }
    }

    // 释放堆上动态分配的内存，避免内存泄漏
    for (int i = 0; i < rows; i++) {
        free(dp[i]);
    }
    free(dp);

    return maxSize * maxSize;
}
```
**关键知识**  
动态规划  内存分配

## 易错点

1. 避免空矩阵，必须进行判空。
2. i-1 或 j-1 越界，遍历时若不处理 i=0 或 j=0，会访问非法内存地址。
3. 手动 malloc 的 DP 数组必须在返回前 free。
4. 记得最后返回的是 maxSize * maxSize